import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:snaptostore/features/projects/domain/models/project_model.dart';
import 'package:snaptostore/features/projects/data/repositories/projects_repository.dart';
import 'package:snaptostore/features/projects/presentation/widgets/project_filters.dart';

// Repository provider
final projectsRepositoryProvider = Provider<ProjectsRepository>((ref) {
return ProjectsRepository();
});

// Projects state
class ProjectsState {
final List<ProjectModel> projects;
final Map<String, int> stats;
final bool isLoading;
final String? error;
final ProjectFilter currentFilter;
final String searchQuery;

const ProjectsState({
  this.projects = const [],
  this.stats = const {},
  this.isLoading = false,
  this.error,
  this.currentFilter = ProjectFilter.all,
  this.searchQuery = '',
});

ProjectsState copyWith({
  List<ProjectModel>? projects,
  Map<String, int>? stats,
  bool? isLoading,
  String? error,
  ProjectFilter? currentFilter,
  String? searchQuery,
}) {
  return ProjectsState(
    projects: projects ?? this.projects,
    stats: stats ?? this.stats,
    isLoading: isLoading ?? this.isLoading,
    error: error,
    currentFilter: currentFilter ?? this.currentFilter,
    searchQuery: searchQuery ?? this.searchQuery,
  );
}

// Filtered projects based on current filter and search
List<ProjectModel> get filteredProjects {
  List<ProjectModel> filtered = projects;

  // Apply search filter
  if (searchQuery.isNotEmpty) {
    filtered = filtered.where((project) {
      return project.title.toLowerCase().contains(searchQuery.toLowerCase()) ||
             project.businessType.toLowerCase().contains(searchQuery.toLowerCase()) ||
             (project.description?.toLowerCase().contains(searchQuery.toLowerCase()) ?? false);
    }).toList();
  }

  // Apply status filter
  switch (currentFilter) {
    case ProjectFilter.drafts:
      filtered = filtered.where((p) => p.isDraft).toList();
      break;
    case ProjectFilter.completed:
      filtered = filtered.where((p) => p.isCompleted).toList();
      break;
    case ProjectFilter.archived:
      filtered = filtered.where((p) => p.isArchived).toList();
      break;
    case ProjectFilter.recent:
      filtered.sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
      filtered = filtered.take(10).toList();
      break;
    case ProjectFilter.favorites:
      // TODO: Implement favorites logic when we add favorites feature
      break;
    case ProjectFilter.all:
    default:
      // Show all non-archived projects by default
      filtered = filtered.where((p) => !p.isArchived).toList();
      break;
  }

  return filtered;
}
}

// Projects provider
class ProjectsNotifier extends StateNotifier<ProjectsState> {
final ProjectsRepository _repository;

ProjectsNotifier(this._repository) : super(const ProjectsState());

// Load all projects
Future<void> loadProjects() async {
  state = state.copyWith(isLoading: true, error: null);
  
  try {
    final projects = await _repository.getUserProjects();
    final stats = await _repository.getProjectStats();
    
    state = state.copyWith(
      projects: projects,
      stats: stats,
      isLoading: false,
    );
  } catch (e) {
    state = state.copyWith(
      error: e.toString(),
      isLoading: false,
    );
  }
}

// Create new project
Future<ProjectModel?> createProject({
  required String title,
  required String businessType,
  String? description,
  String? originalImageUrl,
}) async {
  try {
    final now = DateTime.now();
    final newProject = ProjectModel(
      id: '', // Will be generated by Supabase
      userId: '', // Will be set by repository
      title: title,
      description: description,
      businessType: businessType,
      originalImageUrl: originalImageUrl,
      status: ProjectStatus.draft,
      createdAt: now,
      updatedAt: now,
    );

    final createdProject = await _repository.createProject(newProject);
    
    // Refresh projects list
    await loadProjects();
    
    return createdProject;
  } catch (e) {
    state = state.copyWith(error: e.toString());
    return null;
  }
}

// Update project
Future<bool> updateProject(ProjectModel project) async {
  try {
    final updatedProject = await _repository.updateProject(
      project.copyWith(updatedAt: DateTime.now()),
    );
    
    // Update local state
    final updatedProjects = state.projects.map((p) {
      return p.id == updatedProject.id ? updatedProject : p;
    }).toList();
    
    state = state.copyWith(projects: updatedProjects);
    
    return true;
  } catch (e) {
    state = state.copyWith(error: e.toString());
    return false;
  }
}

// Delete project
Future<bool> deleteProject(String projectId) async {
  try {
    await _repository.deleteProject(projectId);
    
    // Remove from local state
    final updatedProjects = state.projects.where((p) => p.id != projectId).toList();
    state = state.copyWith(projects: updatedProjects);
    
    // Refresh stats
    final stats = await _repository.getProjectStats();
    state = state.copyWith(stats: stats);
    
    return true;
  } catch (e) {
    state = state.copyWith(error: e.toString());
    return false;
  }
}

// Archive project
Future<bool> archiveProject(String projectId) async {
  try {
    final archivedProject = await _repository.archiveProject(projectId);
    
    // Update local state
    final updatedProjects = state.projects.map((p) {
      return p.id == archivedProject.id ? archivedProject : p;
    }).toList();
    
    state = state.copyWith(projects: updatedProjects);
    
    return true;
  } catch (e) {
    state = state.copyWith(error: e.toString());
    return false;
  }
}

// Duplicate project
Future<ProjectModel?> duplicateProject(String projectId, String newTitle) async {
  try {
    final duplicatedProject = await _repository.duplicateProject(projectId, newTitle);
    
    // Add to local state
    final updatedProjects = [...state.projects, duplicatedProject];
    state = state.copyWith(projects: updatedProjects);
    
    return duplicatedProject;
  } catch (e) {
    state = state.copyWith(error: e.toString());
    return null;
  }
}

// Set filter
void setFilter(ProjectFilter filter) {
  state = state.copyWith(currentFilter: filter);
}

// Set search query
void setSearchQuery(String query) {
  state = state.copyWith(searchQuery: query);
}

// Clear search
void clearSearch() {
  state = state.copyWith(searchQuery: '');
}

// Clear error
void clearError() {
  state = state.copyWith(error: null);
}

// Refresh projects
Future<void> refresh() async {
  await loadProjects();
}

// Clear archived projects
Future<bool> clearArchivedProjects() async {
  try {
    await _repository.clearArchivedProjects();
    
    // Remove archived projects from local state
    final updatedProjects = state.projects.where((p) => !p.isArchived).toList();
    state = state.copyWith(projects: updatedProjects);
    
    // Refresh stats
    final stats = await _repository.getProjectStats();
    state = state.copyWith(stats: stats);
    
    return true;
  } catch (e) {
    state = state.copyWith(error: e.toString());
    return false;
  }
}
}

// Provider instance
final projectsProvider = StateNotifierProvider<ProjectsNotifier, ProjectsState>((ref) {
final repository = ref.read(projectsRepositoryProvider);
return ProjectsNotifier(repository);
});

// Convenience providers
final filteredProjectsProvider = Provider<List<ProjectModel>>((ref) {
return ref.watch(projectsProvider).filteredProjects;
});

final projectStatsProvider = Provider<Map<String, int>>((ref) {
return ref.watch(projectsProvider).stats;
});

final isProjectsLoadingProvider = Provider<bool>((ref) {
return ref.watch(projectsProvider).isLoading;
});

final projectsErrorProvider = Provider<String?>((ref) {
return ref.watch(projectsProvider).error;
});